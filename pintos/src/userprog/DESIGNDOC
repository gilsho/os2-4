		     +--------------------------+
         | CS 140	                  |
		     | PROJECT 2: USER PROGRAMS	|
		     | DESIGN DOCUMENT        	|
		     +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Dan Cocuzzo <dcocuzzo@stanford.edu>
Rory MacQueen <macqueen@stanford.edu>
Gil Shotan <gilsho@stanford.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Describe briefly which parts of the assignment were implemented by
>> each member of your team. If some team members contributed significantly
>> more or less than others (e.g. 2x), indicate that here.

No comment.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

No comment.


			   ARGUMENT PASSING
			   ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

#define MAX_PADDING 4

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

We first set up the stack before calling filsys_open

We wrote a parse_args(args,esp,&file_name);

when we copied the args we limit ourselves to a PGSIZE - padding
//int arglen = strnlen(args,PGSIZE) + 1;

then we do one pass over data to count the number of arguments
and then before writing them make sure there is enough space on stack


---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

strtok stores state internally. If multiple threads call strtok
then they may corrupt each other's state. If they are interleaved
then one thread will resume at the other's last saved point. not 
reentrant


>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

shell will crash vs. os crash
you can be more flexible in how you run program
aliases. shell scripts 
some options are meant for the shell and not for the program (|, >, <)




			     SYSTEM CALLS
			     ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

	
in thread.h
------------
	#define MAX_THREAD_OPEN_FILES 128 - the maximum number of open
	files allowed per thread


  
    struct file *exec_file;            a pointer to the current executable th thread is running. used to deny access and allow
    writes on exit

    struct file * fd_table[MAX_THREAD_OPEN_FILES]; /* File desc. table */ keeps a table of the file descriptor mapping to files.
    
    struct process_info *process_info; // a struct containing the information related to the thread's process.


in process.h
------------

typedef int pid_t; //a process id type on the kernel side


in process.c
-------------

struct process_info
{
  pid_t pid;					/* unique process id (same as thread tid) */
  struct lock lock;				/* lock restricting access to info struct */
  int exit_code;				/*	the exit code generated by process, only valid if is_alive is false */
  bool has_been_waited;			/* flag indicating if parent process has waited on this process */
  bool is_alive;				/* indicating whether process has exited */
  bool is_parent_alive;			/* flag indicating whether parent has exited, used for memory management by the process during exited. */
  struct condition cond;		/* used to implement waiting system call */
  struct list_elem child_elem; /* elem in parent list */
  struct list children;   /* list of child processes (struct process_info) */
};

This structure is data passed between parent and child when child is first created (between process_execute and process_start). created on the stack

struct process_init_data
{
  char *args;					// string containing name of executable and arguments of/to program.
  struct semaphore sema;		//synchronization mechanism used to have parent child wiat for completion of load
  bool load_status;				//represents if load of child process was successful. used to signal to parent process.
  struct process_info *info;	//the process information intialized by the parent to stored by child
};

in syscall.c:
-------------
define FILENAME_MAX 14 			//the maxumim number of characters allowed in a file name

struct lock lock_filesys;		// a lock used to restrict access to file system. to allow only one process to use file system at a time




>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?


->global?
each process has its own list of file descriptors, but the file descriptor numbers are unique globally. design choice: know confusion
between interprocess communication. 



---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.


We first pop the arguments off the stack. We try ti find the file descriptor by looking it up in a linked list of file descriptors open by the process. 
We then check that the buffer is ALL(start + end) contained in valid
user virtual address space. 
we then acquire a global file system lock to ensure only one process has access to the file system at a time.
and finally we call the appropriate function from file.c , file_read or file_write. and then push the return value to eax on the interrupt frame.


>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

***If we were to implement our memory using the second approach we wouldn't have had to call pagedir_get_page at all and just rely on the MMU to generate a page fault when an illegal memory access calls.

If we had to inspect every byte address for validity, then it would require as many PTE inspections as bytes to read/write. Hence for a full page that would be 4,096 inspections.

We implemented an improved approach by caching the current page boundary to prevent unneccesary PTE inspections. We assume that the entire current page is valid user memory, therefore we only need to inspect the page table (calling pagedir_get_page) for each page that the data spans, not on every successful address. 

For a full page (4,096 bytes), you would need a minimum of one inspection and a maximum of two inspections. For 2 bytes of data, you would also need a minimum of one inspection and a maximum of two inspections.


>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

first we check if the calling process is trying to wait on one of his children and return -1 otherwise.

We then make sure that this is the first time that the calling process is waiting on this particular child process. otherwise we return -1

We then check that the child info is still alive, and if not we return the error value that the process generated when it terminated that is stored in the process info structure.

If all of the conditions specified above are not met then we call cond_wait on the condition variable associated with the child's "process info structure", releasing the lock. When the child process calss exit, he will signal the current process and wake him up.

we designate this process as being waited on, so that if the parent process tries to wait on him again he will get an error value.



>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.


-> In process_exit (which is called by thread_exit), we destroy the file table, iterating over each open file and closing it.

-> in sytem calls, we use a wrapper function pop_arg that gets a 4 byte word from the top of the stack while encapsulating the error handling.

-> we have defined a function valid_user_addr which combines all necessary checks to be performed on a user address in order to verify its validity: hat the use address is not in kernel space, and that the current page it located in has been allocated.

 (Ask john if we need to free locks acquired?)


---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

Before we load a new process, we pass it a pointer to a struct of initialization data. This struct has an initialized semaphore and a boolean success variable. The semaphore is initialized to value zero, and after the parent process calls load, it tries to down the semaphore, thus blocking. The child process updates the boolean on the init struct after it has loaded it's process, and then calls sema_up on the semaphore. The parent can now proceed, and return from process exec with the new pid of the child, or with an error code if the load was a failure.

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

When a parent process P calls wait(C) on a child, it first checks to see if C is 'alive', i.e. has not yet exited. If C is not alive, then P simply retrieves the exit code of C and returns. If C is alive, then P blocks on a condition variable associated with the child's process info struct. When child C exits, it will signal this condition variable to wake up its parent P who is waiting on that condition. Parent P can then retrieve the exit value of C and return. 

All deallocation of memory happens in process_exit. When a process exits, it first must free the memory of its children who have already exited. It will then check to see if it's parent is still alive, and if not, it will free its own memory. In this way, we account for all cases: either P exits first, in which case it will not free the memory of C (since C is still alive). In this case, C is responsible for freeing its own memory when it exits (which it will do because it will see that its parent is already dead). The other case is that C exits first, in which case it will set itself to be dead, but NOT free its own memory (since its parent is still alive). When P finally exits later, it will free the memory of the dead C process. 


---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

We chose to verify the validity of a user-provided pointer before dereferencing it. The other option (just checking that pointer is below PHYS_BASE) would require us to modify the code in exception.c, which we felt added an unnecessary level of complexity to our system. With our approach, we are keeping the bounds checking all in one place.

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

Each process uses a dynamically allocated linked list to store its open files, along with their file_descriptors. The advantage here is that a process can only have access to its own open files, and there is no danger that it will access, and potentially corrupt, the open file state of another process. It also makes it easy to add open files, as you simply append the new file to the end of a list. Since it is dynamically allocated, we don't need to place a cap on the number of open files that a process can have.
Moreover, we generate file descriptors using a global counter, which means that a file descriptor is not tied to the pointer to the file. This design protects against malicious user programs which might try to dereference a file descriptor to get access to restricted parts of the kernel.

A disadvantage is that, since we are using a global counter to create file descriptors, we need to acquire a global lock every time a process tries to open a file. However we are not preventing any concurrency, since a file would have to acquire the file system lock when it opened a file anyway. Another disadvantage is that doing a lookup on an open file takes O(n) time, since one has to traverse the entire linked list of open files.

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

We have not changed the identity mapping. Unlike file descriptors, tid do not expose sensitive addresses so it is safe to simply cast the tid to a pid and return that to the user. This works because, in pintos, one process corresponds to one thread.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?

