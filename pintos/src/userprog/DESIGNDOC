		     +--------------------------+
         	 | CS 140	                |
		     | PROJECT 2: USER PROGRAMS	|
		     | DESIGN DOCUMENT        	|
		     +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Dan Cocuzzo <dcocuzzo@stanford.edu>
Rory MacQueen <macqueen@stanford.edu>
Gil Shotan <gilsho@stanford.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Describe briefly which parts of the assignment were implemented by
>> each member of your team. If some team members contributed significantly
>> more or less than others (e.g. 2x), indicate that here.

No comment.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

No comment.


			   ARGUMENT PASSING
			   ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

#define MAX_PADDING 4

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

First we copy the entire string of arguments onto the user stack. Then
we make a pass over the arguments and push the starting addresses of
the arguments in a temporary kernel page. We then pop the arguments' start
addresses from the temporary kernel page and place them on the user 
stack in correct order.
During

We have two checks in place to protect against overlowing the stack page.
When we first copy the input string onto the user stack we use strlcpy
and cap the number of bytes copied at just below the page size. We then
check if this cap has been reached and report an error if it has.
Then, after we finised one pass over the argument string in the user
stack and we know the number of arguments, we calculate whether
there is enough space on the user stack to push the elements of arg[v],
argc, and the rest of the bytes required. If we don't have enough space
we return an error.

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

The strtok function store state internally. There is an implicit
assumption that each successive call to str_tok will be made
by the same thread using the same string. Interleaving calls to
str_tok by multiple threads will corrupt the state stored in
str_tok and exhibit undefined behavior. str_tok_r solves this problem
by providing a save_ptr which is passed by reference. This allows
each thread to internally store its own state, allowing multiple 
threads to execute str_tok_r simultaneously

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

1. Parsing command line interfaces minimizes time in kernl mode. If an 
   error occurs while parsing an argument it will crash the shell as 
   opposed to crashing the kernel. The cost of restarting the shell is
   a lot cheaper than restarting the kernel.

2. Parsing arguments in the shell lets the user interleave 
   directives to the shell with arguments to the program. For example,
   the operators "> < | ; &&" are meant to be interperted by the shell.
   If we were to pass in the full string entered by the user to the 
   'exec' system call the kernel would need to know about these special
   symbols.

3. Having the kernel perform the argument parsing means that every 
   program must be executed with its parameters specified in a string
   format delegated by spaces. This is reasonable for arguments passed
   in via the command line interface, but creates unnecessary overhead
   for processes whose list of arguments are known ahead of time. If, for
   example, a program wants to spawn a child process with a fixed set 
   of arguments, the parent process can just go ahead and construct the 
   stack itself rather than convert it into a string format first.

4. Similar to the previous point, if a process wants to spawn multiple
	process with the same set of arguments it can prepare a stack frame
	with the arguments loaded once, and pass the same stack to the kernel
	multiple times. The kernel will just need to scan the stack once
	and copy it to a new location in memory, a much more efficient 
	procedure.


			     SYSTEM CALLS
			     ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

	
in thread.h
------------   
struct process_info *process_info; /* a pointer to a struct containing all information related to the thread's process.


in process.h
------------

typedef int pid_t; /*a process id type on the kernel side */


in process.c
-------------


struct lock lock_filesys; 			/* a lock restricting access to the file system */


/* This struct contains all the information related to a process */

struct process_info
{
  pid_t pid;						/* unique process id (same as thread tid) */
  struct lock lock;					/* lock restricting access to info struct */
  int exit_code;					/*	the exit code generated by process, only valid if is_alive is false */
  bool has_been_waited;				/* flag indicating if parent process has waited on this process */
  bool is_alive;					/* indicating whether process has exited */
  bool is_parent_alive;				/* flag indicating whether parent has exited, used for memory management by the process 
  										during exited. */
  struct condition cond;			/* used to implement the wait system call */
  struct list_elem child_elem;      /* elem in parent list */
  struct list children;             /* list of child processes (struct process_info) */
  struct list fd_table;   			/* list of file descriptors and their associated files */
  struct file *exec_file;           /* a pointer to the current executable file that thread is running. used to deny access to the 
  										file while program is running  */ 
  int cur_fd;
};


/* This struct is used to pass more than one variable between a parent process' process_execute call and a child process' start_process function. */

struct process_init_data
{
  char *args;					/* string containing name of executable and arguments of/to program. */
  struct semaphore sema;		/* synchronization mechanism used to have parent child wiat for completion of load */
  bool load_status;				/* represents if load of child process was successful. used to signal to parent process. */
  struct process_info *info;	/* the process information intialized by the parent to stored by child */
};

/* This struct is a node element in a linked list of file descriptors mapping to open files. */
struct file_desc
{
  int fd;						/* the file descriptor associated with the node */
  struct file *file;			/* a handle to the file struct associated with fd */
  struct list_elem elem;		/* a list elem used to embedd node within a larger list of nodes */
};


in syscall.c:
-------------
define FILENAME_MAX 14 			/* maxumim number of characters allowed in a file name */


>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?


->global?
each process has its own list of file descriptors, but the file descriptor numbers are unique globally. design choice: know confusion
between interprocess communication. 



---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.


We first pop the arguments off the stack. We try ti find the file descriptor by looking it up in a linked list of file descriptors open by the process. 
We then check that the buffer is ALL(start + end) contained in valid
user virtual address space. 
we then acquire a global file system lock to ensure only one process has access to the file system at a time.
and finally we call the appropriate function from file.c , file_read or file_write. and then push the return value to eax on the interrupt frame.


>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

***If we were to implement our memory using the second approach we wouldn't have had to call pagedir_get_page at all and just rely on the MMU to generate a page fault when an illegal memory access calls.

If we had to inspect every byte address for validity, then it would require as many PTE inspections as bytes to read/write. Hence for a full page that would be 4,096 inspections.

We implemented an improved approach by caching the current page boundary to prevent unneccesary PTE inspections. We assume that the entire current page is valid user memory, therefore we only need to inspect the page table (calling pagedir_get_page) for each page that the data spans, not on every successful address. 

For a full page (4,096 bytes), you would need a minimum of one inspection and a maximum of two inspections. For 2 bytes of data, you would also need a minimum of one inspection and a maximum of two inspections.


>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

first we check if the calling process is trying to wait on one of his children and return -1 otherwise.

We then make sure that this is the first time that the calling process is waiting on this particular child process. otherwise we return -1

We then check that the child info is still alive, and if not we return the error value that the process generated when it terminated that is stored in the process info structure.

If all of the conditions specified above are not met then we call cond_wait on the condition variable associated with the child's "process info structure", releasing the lock. When the child process calss exit, he will signal the current process and wake him up.

we designate this process as being waited on, so that if the parent process tries to wait on him again he will get an error value.



>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.


-> In process_exit (which is called by thread_exit), we destroy the file table, iterating over each open file and closing it.

-> in sytem calls, we use a wrapper function pop_arg that gets a 4 byte word from the top of the stack while encapsulating the error handling.

-> we have defined a function valid_user_addr which combines all necessary checks to be performed on a user address in order to verify its validity: hat the use address is not in kernel space, and that the current page it located in has been allocated.

 (Ask john if we need to free locks acquired?)


---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

Before we load a new process, we pass it a pointer to a struct of initialization data. This struct has an initialized semaphore and a boolean success variable. The semaphore is initialized to value zero, and after the parent process calls load, it tries to down the semaphore, thus blocking. The child process updates the boolean on the init struct after it has loaded it's process, and then calls sema_up on the semaphore. The parent can now proceed, and return from process exec with the new pid of the child, or with an error code if the load was a failure.

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

When a parent process P calls wait(C) on a child, it first checks to see if C is 'alive', i.e. has not yet exited. If C is not alive, then P simply retrieves the exit code of C and returns. If C is alive, then P blocks on a condition variable associated with the child's process info struct. When child C exits, it will signal this condition variable to wake up its parent P who is waiting on that condition. Parent P can then retrieve the exit value of C and return. 

All deallocation of memory happens in process_exit. When a process exits, it first must free the memory of its children who have already exited. It will then check to see if it's parent is still alive, and if not, it will free its own memory. In this way, we account for all cases: either P exits first, in which case it will not free the memory of C (since C is still alive). In this case, C is responsible for freeing its own memory when it exits (which it will do because it will see that its parent is already dead). The other case is that C exits first, in which case it will set itself to be dead, but NOT free its own memory (since its parent is still alive). When P finally exits later, it will free the memory of the dead C process. 


---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

We chose to verify the validity of a user-provided pointer before dereferencing it. The other option (just checking that pointer is below PHYS_BASE) would require us to modify the code in exception.c, which we felt added an unnecessary level of complexity to our system. With our approach, we are keeping the bounds checking all in one place.

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

Each process uses a dynamically allocated linked list to store its open files, along with their file_descriptors. The advantage here is that a process can only have access to its own open files, and there is no danger that it will access, and potentially corrupt, the open file state of another process. It also makes it easy to add open files, as you simply append the new file to the end of a list. Since it is dynamically allocated, we don't need to place a cap on the number of open files that a process can have.
Moreover, we generate file descriptors using a process-specific counter, which means that a file descriptor is not tied to the pointer to the file. This design protects against malicious user programs which might try to dereference a file descriptor to get access to restricted parts of the kernel.

A disadvantage is that doing a lookup on an open file using a file descriptor takes O(n) time, since one has to traverse the entire linked list of open files. Also, since each process is maintaining its own list, there is a fair amount of memory overhead to keep track of open files.

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

We have not changed the identity mapping. Unlike file descriptors, tid do not expose sensitive addresses so it is safe to simply cast the tid to a pid and return that to the user. This works because, in pintos, one process corresponds to one thread.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?

