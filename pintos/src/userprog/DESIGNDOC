		     +--------------------------+
         | CS 140	                  |
		     | PROJECT 2: USER PROGRAMS	|
		     | DESIGN DOCUMENT        	|
		     +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Dan Cocuzzo <dcocuzzo@stanford.edu>
Rory MacQueen <macqueen@stanford.edu>
Gil Shotan <gilsho@stanford.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Describe briefly which parts of the assignment were implemented by
>> each member of your team. If some team members contributed significantly
>> more or less than others (e.g. 2x), indicate that here.

No comment.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

No comment.


			   ARGUMENT PASSING
			   ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

#define MAX_PADDING 4

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

We first set up the stack before calling filsys_open

We wrote a parse_args(args,esp,&file_name);

when we copied the args we limit ourselves to a PGSIZE - padding
//int arglen = strnlen(args,PGSIZE) + 1;

then we do one pass over data to count the number of arguments
and then before writing them make sure there is enough space on stack


---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

strtok stores state internally. If multiple threads call strtok
then they may corrupt each other's state. If they are interleaved
then one thread will resume at the other's last saved point. not 
reentrant


>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

shell will crash vs. os crash
you can be more flexible in how you run program
aliases. shell scripts 
some options are meant for the shell and not for the program (|, >, <)




			     SYSTEM CALLS
			     ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

	
in thread.h
------------
	#define MAX_THREAD_OPEN_FILES 128 - the maximum number of open
	files allowed per thread


  
    struct file *exec_file;            a pointer to the current executable th thread is running. used to deny access and allow
    writes on exit

    struct file * fd_table[MAX_THREAD_OPEN_FILES]; /* File desc. table */ keeps a table of the file descriptor mapping to files.
    
    struct process_info *process_info; // a struct containing the information related to the thread's process.


in process.h
------------

typedef int pid_t; //a process id type on the kernel side


in process.c
-------------

struct process_info
{
  pid_t pid;					/* unique process id (same as thread tid) */
  struct lock lock;				/* lock restricting access to info struct */
  int exit_code;				/*	the exit code generated by process, only valid if is_alive is false */
  bool has_been_waited;			/* flag indicating if parent process has waited on this process */
  bool is_alive;				/* indicating whether process has exited */
  bool is_parent_alive;			/* flag indicating whether parent has exited, used for memory management by the process during exited. */
  struct condition cond;		/* used to implement waiting system call */
  struct list_elem child_elem; /* elem in parent list */
  struct list children;   /* list of child processes (struct process_info) */
};

This structure is data passed between parent and child when child is first created (between process_execute and process_start). created on the stack

struct process_init_data
{
  char *args;					// string containing name of executable and arguments of/to program.
  struct semaphore sema;		//synchronization mechanism used to have parent child wiat for completion of load
  bool load_status;				//represents if load of child process was successful. used to signal to parent process.
  struct process_info *info;	//the process information intialized by the parent to stored by child
};

in syscall.c:
-------------
define FILENAME_MAX 14 			//the maxumim number of characters allowed in a file name

struct lock lock_filesys;		// a lock used to restrict access to file system. to allow only one process to use file system at a time




>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?


->global?
each process has its own list of file descriptors, but the file descriptor numbers are unique globally. design choice: know confusion
between interprocess communication. 



---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.


We first pop the arguments off the stack. We try ti find the file descriptor by looking it up in a linked list of file descriptors open by the process. 
We then check that the buffer is ALL(start + end) contained in valid
user virtual address space. 
we then acquire a global file system lock to ensure only one process has access to the file system at a time.
and finally we call the appropriate function from file.c , file_read or file_write. and then push the return value to eax on the interrupt frame.


>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

***If we were to implement our memory using the second approach we wouldn't have had to call pagedir_get_page at all and just rely on the MMU to generate a page fault when an illegal memory access calls.

If we had to inspect every byte address for validity, then it would require as many PTE inspections as bytes to read/write. Hence for a full page that would be 4,096 inspections.

We implemented an improved approach by caching the current page boundary to prevent unneccesary PTE inspections. We assume that the entire current page is valid user memory, therefore we only need to inspect the page table (calling pagedir_get_page) for each page that the data spans, not on every successful address. 

For a full page (4,096 bytes), you would need a minimum of one inspection and a maximum of two inspections. For 2 bytes of data, you would also need a minimum of one inspection and a maximum of two inspections.


>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

first we check if the calling process is trying to wait on one of his children and return -1 otherwise.

We then make sure that this is the first time that the calling process is waiting on this particular child process. otherwise we return -1

We then check that the child info is still alive, and if not we return the error value that the process generated when it terminated that is stored in the process info structure.

If all of the conditions specified above are not met then we call cond_wait on the condition variable associated with the child's "process info structure", releasing the lock. When the child process calss exit, he will signal the current process and wake him up.

we designate this process as being waited on, so that if the parent process tries to wait on him again he will get an error value.



>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.


-> In process_exit (which is called by thread_exit), we destroy the file table, iterating over each open file and closing it.

-> in sytem calls, we use a wrapper function pop_arg that gets a 4 byte word from the top of the stack while encapsulating the error handling.

-> we have defined a function valid_user_addr which combines all necessary checks to be performed on a user address in order to verify its validity: hat the use address is not in kernel space, and that the current page it located in has been allocated.

 (Ask john if we need to free locks acquired?)


---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

init_data.semaphore. we down it in execute, up it in start_process. it works no matter what order these operations are performed (so the child process can up it before parent downs it).

inside the init_data data structure that is passed by reference to the child thread, we include a load_status variable that allows the child process to communicate this value back to the parent thread.

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

Just before P waits P blocks on a condition variable that is associated with C (C's process info structure) and C signals P when he exits.

When C exits, he sets a flag in his process info struct that indicates that he is no longer alive. P, when trying to wait on C, will read this value and avoid blocking, and read and return the child's exit code immediately. 

Deallocation procedure in process exit: 
In our implementation each process destroys his own meta data 
and his childrens meta datam
stored in a process info struct. A parent will free its resources if and only if his parent P has terminated. If when he terminates his parent his still alive, then his parent will free his resources when his parent terminates.

Either the parent finished first or the child finishes first, but by making sure that a parent frees the resources of this "dead" children when it exits and that the child frees its parent's resources when the child exits, we have covered all possible scenarios.

All freeing of resources occur when processes exit, whether or not the process has waited has no bearing whatsoever. 


---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

Simplicity. option 2 would have required us to modify exception code much. This would have introduced a whole new world of pain that we didn't want to deal with.

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

Each process uses a dynamically allocated linked list to store its open files, along with their file_descriptors. 

Even though each process can only access its own open files, we use a global counter to generate the file descriptors just in case two prcocess decide to share information. ....

advantage: easy to add open files. no collisions between process over file descriptors.
dynamically allocated storage. no limit on number of files to open.
file descriptors are not pointers to the file structures. This protects against malicious user programs that will try to give the kernel a fabricated file descriptor and use that to gain access to restricted parts of memory.

disadvantage:
- one global lock each time a process tries to open a file all process must block. we figured this is not too bad since there is already a global lock tha restricts access to file system one at a time.
O(n) run time for doing things with files. have to look through linked list

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

we haven't changed the mapping. we figured that unlike file descriptors, tid do not expose sensitive addresses so it was safe to make them visible to the user and as identifier for processes as well, since in pintos a process consists of one thread. 

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?

