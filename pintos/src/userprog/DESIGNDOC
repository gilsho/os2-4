		     +--------------------------+
         	 | CS 140	                |
		     | PROJECT 2: USER PROGRAMS	|
		     | DESIGN DOCUMENT        	|
		     +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Dan Cocuzzo <dcocuzzo@stanford.edu>
Rory MacQueen <macqueen@stanford.edu>
Gil Shotan <gilsho@stanford.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Describe briefly which parts of the assignment were implemented by
>> each member of your team. If some team members contributed significantly
>> more or less than others (e.g. 2x), indicate that here.

No comment.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

No comment.


			   ARGUMENT PASSING
			   ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

#define MAX_PADDING 4

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

The first thing we do is initialize the user stack. We then call parse_args,
a function that we defined, to place the arguments passed in to the user
onto the stack in the correct format. Inside parse_args, we copy the
string containing the file name and arguments onto the user stack
in its entirety. We then call str_tok_r on the string loaded in the user
stack and replace the spaces with null terminating characters. During
this pass we push the starting address of each argument to a temporary
kernel page. Once we are finished, we cycle through all the starting addresses
of the arguments we stored in the temporary kernel page and push them onto
the user stack. This ensures the pointer to the arguemnts are placed
in the correct order. 

We have two checks in place to protect against overlowing the stack page.
When we first copy the input string onto the user stack we use strlcpy
and cap the number of bytes copied at just below the page size. We then
check if this cap has been reached and report an error if it has.
Then, after we finised one pass over the argument string in the user
stack, and inserted null terminating character, we calculate whether
there is enough space on the user stack to push the elements of arg[v],
argc, and the rest of the bytes required. If we don't have enough space
we return an error.

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

The strtok function store state internally. There is an implicit
assumption that each successive call to str_tok will be made
by the same thread using the same string. Interleaving calls to
str_tok by multiple threads will corrupt the state stored in
str_tok and exhibit undefined behavior. str_tok_r solves this problem
by providing a save_ptr which is passed by reference. This allows
each thread to internally store its own state, allowing multiple 
threads to execute str_tok_r simultaneously

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

1. Parsing command line interfaces minimizes time in kernl mode. If an 
   error occurs while parsing an argument it will crash the shell as 
   opposed to crashing the kernel. The cost of restarting the shell is
   a lot cheaper than restarting the kernel.

2. Parsing arguments in the shell lets the user interleave 
   directives to the shell with arguments to the program. For example,
   the operators "> < | ; &&" are meant to be interperted by the shell.
   If we were to pass in the full string entered by the user to the 
   'exec' system call the kernel would need to know about these special
   symbols.

3. Having the kernel perform the argument parsing means that every 
   program must be executed with its parameters specified in a string
   format delegated by spaces. This is reasonable for arguments passed
   in via the command line interface, but creates unnecessary overhead
   for processes whose list of arguments are known ahead of time. If, for
   example, a program wants to spawn a child process with a fixed set 
   of arguments, the parent process can just go ahead and construct the 
   stack itself rather than convert it into a string format first.

4. Similar to the previous point, if a process wants to spawn multiple
	process with the same set of arguments it can prepare a stack frame
	with the arguments loaded once, and pass the same stack to the kernel
	multiple times. The kernel will just need to scan the stack once
	and copy it to a new location in memory, a much more efficient 
	procedure.


			     SYSTEM CALLS
			     ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

	
in thread.h
------------
    struct file *exec_file;   /* a pointer to the current executable file that thread is running. used to deny access to the file 								 while program is running  */

    struct file * fd_table;   /* File descriptor table. Stores a list of file descriptor mapping to files.
    
    struct process_info *process_info; /* a pointer to a struct containing the information related to the thread's process.


in process.h
------------

typedef int pid_t; /*a process id type on the kernel side */


in process.c
-------------

/* This struct contains all the information related to a process */
struct process_info
{
  pid_t pid;					/* unique process id (same as thread tid) */
  struct lock lock;				/* lock restricting access to info struct */
  int exit_code;				/*	the exit code generated by process, only valid if is_alive is false */
  bool has_been_waited;			/* flag indicating if parent process has waited on this process */
  bool is_alive;				/* indicating whether process has exited */
  bool is_parent_alive;			/* flag indicating whether parent has exited, used for memory management by the process 
  									during exited. */
  struct condition cond;		/* used to implement the wait system call */
  struct list_elem child_elem; 	/* elem in parent list */
  struct list children;   		/* list of process_info structs of child processes */
};


/* This struct is used to pass more than one variable between a parent process' process_execute call and a child process' start_process function. */

struct process_init_data
{
  char *args;					/* string containing name of executable and arguments of/to program. */
  struct semaphore sema;		/* synchronization mechanism used to have parent child wiat for completion of load */
  bool load_status;				/* represents if load of child process was successful. used to signal to parent process. */
  struct process_info *info;	/* the process information intialized by the parent to stored by child */
};

in syscall.c:
-------------
define FILENAME_MAX 14 			/* maxumim number of characters allowed in a file name */

struct lock lock_filesys;		/* a lock used to restrict access to the file system. Allows 
									only one process to use file system at a time */




>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?


->global?
each process has its own list of file descriptors, but the file descriptor numbers are unique globally. design choice: know confusion
between interprocess communication. 



---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.


We first pop the arguments off the stack. We try ti find the file descriptor by looking it up in a linked list of file descriptors open by the process. 
We then check that the buffer is ALL(start + end) contained in valid
user virtual address space. 
we then acquire a global file system lock to ensure only one process has access to the file system at a time.
and finally we call the appropriate function from file.c , file_read or file_write. and then push the return value to eax on the interrupt frame.


>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

***If we were to implement our memory using the second approach we wouldn't have had to call pagedir_get_page at all and just rely on the MMU to generate a page fault when an illegal memory access calls.

If we had to inspect every byte address for validity, then it would require as many PTE inspections as bytes to read/write. Hence for a full page that would be 4,096 inspections.

We implemented an improved approach by caching the current page boundary to prevent unneccesary PTE inspections. We assume that the entire current page is valid user memory, therefore we only need to inspect the page table (calling pagedir_get_page) for each page that the data spans, not on every successful address. 

For a full page (4,096 bytes), you would need a minimum of one inspection and a maximum of two inspections. For 2 bytes of data, you would also need a minimum of one inspection and a maximum of two inspections.


>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

first we check if the calling process is trying to wait on one of his children and return -1 otherwise.

We then make sure that this is the first time that the calling process is waiting on this particular child process. otherwise we return -1

We then check that the child info is still alive, and if not we return the error value that the process generated when it terminated that is stored in the process info structure.

If all of the conditions specified above are not met then we call cond_wait on the condition variable associated with the child's "process info structure", releasing the lock. When the child process calss exit, he will signal the current process and wake him up.

we designate this process as being waited on, so that if the parent process tries to wait on him again he will get an error value.



>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.


-> In process_exit (which is called by thread_exit), we destroy the file table, iterating over each open file and closing it.

-> in sytem calls, we use a wrapper function pop_arg that gets a 4 byte word from the top of the stack while encapsulating the error handling.

-> we have defined a function valid_user_addr which combines all necessary checks to be performed on a user address in order to verify its validity: hat the use address is not in kernel space, and that the current page it located in has been allocated.

 (Ask john if we need to free locks acquired?)


---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

init_data.semaphore. we down it in execute, up it in start_process. it works no matter what order these operations are performed (so the child process can up it before parent downs it).

inside the init_data data structure that is passed by reference to the child thread, we include a load_status variable that allows the child process to communicate this value back to the parent thread.

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

Just before P waits P blocks on a condition variable that is associated with C (C's process info structure) and C signals P when he exits.

When C exits, he sets a flag in his process info struct that indicates that he is no longer alive. P, when trying to wait on C, will read this value and avoid blocking, and read and return the child's exit code immediately. 

Deallocation procedure in process exit: 
In our implementation each process destroys his own meta data 
and his childrens meta datam
stored in a process info struct. A parent will free its resources if and only if his parent P has terminated. If when he terminates his parent his still alive, then his parent will free his resources when his parent terminates.

Either the parent finished first or the child finishes first, but by making sure that a parent frees the resources of this "dead" children when it exits and that the child frees its parent's resources when the child exits, we have covered all possible scenarios.

All freeing of resources occur when processes exit, whether or not the process has waited has no bearing whatsoever. 


---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

Simplicity. option 2 would have required us to modify exception code much. This would have introduced a whole new world of pain that we didn't want to deal with.

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

Each process uses a dynamically allocated linked list to store its open files, along with their file_descriptors. 

Even though each process can only access its own open files, we use a global counter to generate the file descriptors just in case two prcocess decide to share information. ....

advantage: easy to add open files. no collisions between process over file descriptors.
dynamically allocated storage. no limit on number of files to open.
file descriptors are not pointers to the file structures. This protects against malicious user programs that will try to give the kernel a fabricated file descriptor and use that to gain access to restricted parts of memory.

disadvantage:
- one global lock each time a process tries to open a file all process must block. we figured this is not too bad since there is already a global lock tha restricts access to file system one at a time.
O(n) run time for doing things with files. have to look through linked list

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

we haven't changed the mapping. we figured that unlike file descriptors, tid do not expose sensitive addresses so it was safe to make them visible to the user and as identifier for processes as well, since in pintos a process consists of one thread. 

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?

