        +---------------------------+
		    | CS 140                    |
		    | PROJECT 3: VIRTUAL MEMORY	|
		    |	DESIGN DOCUMENT           |
		    +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Describe briefly which parts of the assignment were implemented by
>> each member of your team. If some team members contributed significantly
>> more or less than others (e.g. 2x), indicate that here.

FirstName LastName: contribution
FirstName LastName: contribution
FirstName LastName: contribution

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

page supplemental table

---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.

a thread has a page supplemental table, which contains a pointer to the
kernel address of the frame containing the page, given that the page in
in memory.
-> upage is the hash key in the page supplemental table

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

We are avoiding the issue. we only access memory in kernel using 
the kernel address.
-> we may  need to set dirty+accessed manually in write, ad set
accessed in sys_read. OFFICE HOURS. need to check if we need to
do this elsewhere



---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

lock_frame is acquired prior to allocating a new frame, and is held 
throughout the process of eviction (if necessary) and re-mapping the 
frame to the new process

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

-> page_supplemental table is hash for quick look up
- frame table (trick with two struct elems in pse) is list 
for consistent iteration.

		       PAGING TO AND FROM DISK
		       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

frame table
swap bitmap.

THE UNION

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

clock_algorithm. jump over pin pages, also skip pages that are currently
being updates to avoid blocking in the middle of eviction (lock_try_acquire).
and race conditions (invariant: always acquire frame lock before pse locks).
skip accessed bits and clear them. 
--> look at frame_alloc


>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect that frame Q no longer has it?

we also take it off the frame list (the struct).
pse->ploc = ploc_swap OR ploc_file.
--> don't forget to put the page_location enum in B1.
--> look at frame_evict


>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

we keep track of stack_base (don't forget to include this in B1 or somewhere).
and if it's a legal access (up to 32 bytes below esp), then we allocate a new
page. also we check that we didn't exceed the max stack size (MIN_STACK_BASE).
-->exception.c: is_valid_stack_access
-->exception.c: handle_stack_access.

check legal access->check extension required->check is extension allowed.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

we always matain a hierarachy in locks. ALWAYS get the frame lock
before acquiring pse locks. skip over acquired pse locks. breaks
condition 4 of deadlocks: circularity.

IDE?

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

to access or modify your pse you must acquire a lock (that every pse
has). 
Q is going to block on his pse lock if he tries to fault. only when
P finishes eviction will he release Q's pse lock.

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

Q is going to block on frame_lock. basically we can only serve one
page fault and/or eviction at a time.

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

Kernel page faults are catastrophic and cause the kernel to crash
because the kernel attempts to acquire the IDE device lock that it already
holds. This is because a read or write system call invoked by a user 
process involves both an external file and a buffer location in user virtual
memory, so the kernel may page fault while trying to access the
user buffer after it has acquired the IDE lock, and therefore cannot
load the buffer memory page.

We use a pinning mechanism to avoid kernel page faults that might
occur during system calls. A page that is pinned is immediately
loaded into a physical memory frame and can NOT be evicted. This is
implemented through the use of locks on supplemental page table entries.

Prior to reading/writing the buffer from/to file, we verify that the
head and tail addresses of the buffer are valid user virtual addresses.
We then compute the addresses of all user pages (using the read/write size)
that the buffer spans and verify that they are installed in the 
supplemental page table. If any of these checks fail, we fail gracefully 
by terminating the user process, but the OS continues to run unaffected.

We then pin each buffer page individually before reading/writing its
data, and unpin it immediately after this operation is finished. We feel 
that page/frame pinning is a simple solution to this problem that does 
not incur significant overhead because only one page/frame may be pinned
at a given time for each given process.

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

Our design has several locks to prevent race conditions while still
allowing a high degree of parallelism.

Similar to the global filesystem lock that was implemented in project
2, we use a global lock on the frame list to ensure that there are
no race conditions when inspecting or modifying elements or the list
structure itself. We chose to use a global lock because the frame list 
itself is a global data structure that is shared among all active threads.

However, we use individual locks on the supplemental page table
entries for all processes. These locks must be acquired before inspecting
or modifying any entry fields.

Using multiple locks increases the likelihood of introducing
deadlock conditions. To prevent deadlock, we require that locks are acquired
in a specific order when multiple locks are needed for an operation.

The loading and eviction functions are the only tasks that need
to acquire multiple locks. For both of these routines, a process must first 
acquire the frame list lock before acquiring the supplemental page table
entry lock. During eviction of a frame, a process may modify the supplemental
page table entry owned by a different process, and it must acquire the
lock for that entry only after it has acquired the frame lock.

In all other cases, such as when a process needs to inspect or modify one
of its supplemental page table entries without modifying the frame list, the
owning process will block until that lock of that entry is released.


			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

-----------------------------
mmap.h
-----------------------------

typedef int mapid_t;						/* user identifier for memory mapped files
																   used as the hashed key in a mmap_table */
typedef struct hash mmap_table; /* type def for mmap_table hash table */

struct mmap_entry 
{
  mapid_t mid;						/* (hash key) mmap file identifier */
	void *upage;						/* first page in user memory */
	struct file *file;			/* handler of backing file */
	uint32_t file_len;			/* byte-size of file */
	struct hash_elem elem;	/* hash table element */
};

-----------------------------
process.c
-----------------------------

Each process/thread has its own mmap_table (hash table) of memory-mapped files.
The mmap_table is stored in the process_info struct:

struct process_info
{
	...
	mapid_t next_mid;     /* mapid_t counter localized to each process */
  mmap_table mmt;       /* hash table of memory mapped files */
	...
}

-----------------------------
pagesup.h
-----------------------------
enum page_type 					/* indicates the type of user memory page entry */
{
  ptype_stack,							/* stack page */
  ptype_segment,						/* writable segment page */
  ptype_segment_readonly,		/* read-only segment page */
  ptype_file								/* mem-mapped file page */
};

enum page_location			/* indicates the current location of a user page */
{
	ploc_none,				/* page data does not exist anywhere (new stack pages) */
	ploc_memory,			/* page data resides in a physical frame */
	ploc_file,				/* page data resides in an external file */
	ploc_swap					/* page data resides in a swap slot */
};

struct file_info			/* used to retrieve page data from file */
{
	struct file *file;	/* external file struct */
	off_t offset;				/* offset location within the file */
};

struct swap_info			/* used to retrieve page data from swap */
{
	size_t slot_index;	/* swap slot where the page data resides */
};

union pagesup_info		/* union for storing information about
											 external page data to be loaded in */
{										
	struct file_info f;		/* used to retrieve page data from file */
	struct swap_info s;		/* used to retrieve page data from swap */
};

struct pagesup_entry 			/* supplemental page table entry */
{
	void *upage; 						/* used to generate hash */
	void *kpage;						/* kernel page virtual address */
	int valid_bytes;				/* valid bytes on the give page */
	enum page_type ptype;		/* type of user page */
	enum page_location ploc;	/* current location of user page data */
	struct thread *owner;			/* pointer to owning thread, (used for eviction) */
	struct lock lock;					/* lock needed to modify struct fields */
	struct hash_elem pagesup_elem;	/* supplemental page table elem */
	struct list_elem frame_elem;    /* frame list elem */
	union pagesup_info info;	/* info for loading page data. the union is
															 cast as a file_info or swap_info depending
															 on the ptype
};

Each pagesup_entry contains a union pagesup_info, whose contents can either
be interpreted as a struct file_info or struct swap_info. For pages that are
installed for memory-mapped files, the contents of pagesup_info will always 
be accessed as a struct file_info.

We chose to use a UNION so that our supplemental page table entries could
be generalized to handle all types of loaded data (file, stack, segment), 
while still maintaining specificity of file locations versus swap slots 
when necessary.


---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

Our implementation differentiates between several types
of memory pages using an enum page_type indicator that is stored
in each of the supplemental page table entries. The page_type field 
is set by the OS during installation of a page and is inspected during
the loading and releasing of pages. These inspections are usually triggered
through page-faults, but occur when unmapping memory-mapped files as well.

When a file is mapped to memory by the user process using the 'mmap' system
call, we use the file-size to compute the number of necessary pages to install
in virtual memory for that file (after checking the validity of the user 
memory region). Then we install the appropriate number of pages to map the
file into the supplemental page table. Each of the installed page contains
a handle of the file struct containing the backing data, an offset indicating
where in the file the data for the page is located, and a number of valid_bytes
that the page contains. valid_bytes will be PGSIZE for all pages except for the
last, because the file may not contain an exact multiple of PGSIZE bytes.

Upon user-access of a mmapped page, the process of retrieving the underlying
data is nearly identical to that of code, data, or stack. After acquiring a
frame, the function vman_load_page_helper (in vman.c) detects the page has
ptype_file and issues a filesystem read to retreive the data.

If the OS is unable to acquire a frame during frame_alloc(), then eviction
will occur. If eviction occurs on a frame that corresponds to a memory-mapped
file's page, the eviction algorithm (frame_evict) will detect that the
page has ptype_file and will write the data back to the underlying file
(NOT swap) only if it is dirty. If the page is not dirty, there is no need to 
write out the data and the containing frame is released for use.

For writable segment pages (ptype_segment), eviction will write them to an
available swap slot, and for read-only segment pages (ptype_segment_readonly),
eviction will simply discard the contents since they can be fetched from
the executable again.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

The mmap system call retrieves file descriptor and the user virtual address
at which to start mapping the file, which must be page aligned. Given
the file descriptor, we retrieve the file length in bytes and compute the 
number of pages required to map the entire file. We iterate over all 
required user virtual addresses corresponding to the necessary pages
and verify that there does not already exist a mapping in the supplementary
page table (function vman_upages_unmapped). If a page mapping exists for any 
of the required pages, we know that the requested file mapping will overlap 
another segment and thus return an error (-1) to the user. If all of
the requested virtual pages are unmapped, we install the necessary virtual
pages into the supplemental page table.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.


All virtual pages, whether segment, stack, or mem-mapped files, are installed
into the supplemental page table using pagesup_entry structs and loaded lazily
as needed during page faults. While the semantics of segments and mmapped
files is similar, our implementation maintains unique interfaces to install 
segment and file mappings because it provides more readable code. For example,
emory-mapped files do not have regions of uninitialized data, and the
read/write permissions are determined when the file itself is opened, not
by the mapping process. However, segment pages must be explicitly installed
with this information when the executable header is interpreted. For 
specifics, see vman_map_file versus vman_map_segment.

We store two enum fields, ptype and ploc, in each entry to indicate how the 
OS should handle loads and evictions of each page/frame. The location field
ploc is primarily used for determining where writable segment data currently
resides, but all pages that have been loaded to physical frames have
their location set to ploc_memory to indicate that they are present.

The procedures for allocating/evicting frames and actually loading the page 
data is shared between all types of user pages. The eviction (frame_evict) and 
loading (vman_load_page) functions inspect the page type (ptype) field of
a given supplemental page table entry. For mem-mapped files, the loading
procedure will read the valid bytes to an active page, and the eviction
procedure will similarly write the valid bytes of a page back to the 
file if the page is dirty. Once a mem-mapped page is evicted, its location
ploc is set to ploc_file to indicate where it resides for later access.



			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

We felt that the implementation of memory-mapped files adds extra
work to this project without enriching the underlying OS system. It
could be omitted, 

Don't understand the significance of implementing memory mapped files.

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?