        +---------------------------+
		    | CS 140                    |
		    | PROJECT 3: VIRTUAL MEMORY	|
		    |	DESIGN DOCUMENT           |
		    +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.


Dan Cocuzzo <dcocuzzo@stanford.edu>
Rory MacQueen <macqueen@stanford.edu>
Gil Shotan <gilsho@stanford.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Describe briefly which parts of the assignment were implemented by
>> each member of your team. If some team members contributed significantly
>> more or less than others (e.g. 2x), indicate that here.

All team members implemented all functionality of the project together

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

None.

			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

in thread.h:
------------

struct thread {
    pagesup_table pst;                  /* Supplemental page table */
}


in pagesup.h:
-------------

/* the underlying data structure for the page supplementary table is a hash map */
typedef struct hash pagesup_table;

/* identifies the type of page mapped to the virtual address */
enum page_type 
{
  ptype_stack,									/* a stack page */
  ptype_segment,								/* a page mapped to a read/write segment (data) */
  ptype_segment_readonly,				/* a page mapped to a read only segment page (code) */
  ptype_file										/* a page mapped to a memory mapped file */
};

/* identifies the current location of a page */
enum page_location
{
	ploc_none,									/* does not exist yet */
	ploc_memory,								/* lives in memory */
	ploc_file,									/* written to a memory mapped file*/
	ploc_swap										/* swapped out to disk */
};

/* an entry in the page supplemental table associated with a virtual address */
struct pagesup_entry 
{
	void *upage; 												/* the virtual address of a page, used to generate hash */
	void *kpage;												/* the physical address of a page if it is currently in memory */
	int valid_bytes;										/* the number of bytes that are physically mapped. 
																				 values written beyond this  will be discarded if and when written to disk*/
	enum page_type ptype;								/* the type of the page being mapped */
	enum page_location ploc;						/* the current location of the page: memory,disk,file */
	struct thread *owner;								/* a back-pointer the thread whose page supplementary table the entry is a member of */
	struct lock lock;										/* a lock used to synchornize access to the page supplementary entry */
	struct hash_elem pagesup_elem;			/* h hash elem used to embedd this entry into the page supplemental hash table */
	struct list_elem frame_elem;				/* a list elem used to embedd this entry into a list of frames. 
																				 used only if the current entry is located in memory */
	....

};



---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.

Given a page, we lookup the entry corresponding to that page in the
supplemental page table. The supplemental page table is a hash map,
and the user virtual address of the page is used to compute the hash value
by which the supplemental page table entry is indexed.

The 'ploc' field of the page supplemental entry tells us whether this
page currently resides in memory. If so, the 'kpage' field contains
the kernel virtual address (physical address) of the frame.

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

We only access user memory through user virtual addresses. Therefore the 
hardware takes care of updating the accessed and dirty bits in the page 
directory.


---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

When a process P1 page faults and requires a new frame it must obtain the frame lock (lock_frame). Any other process that page faults while 
the handler is handling P1's page fault will block. The frame lock
will be released only when the handler finishes allocating the frame.
Thus, our implementation supports only one frame allocation at a time.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

We used a hash map to represent our virtual-to-physical mapping.
The key for the hash map is the user virtual address of the page, and 
the value of the hash map is a struct containg the kernel virtual address 
of the page. We chose this design for its speed of access and limited use 
of memory. Since page faults must be handled very quickly, locating the 
information associated with that page in the supplemental page table should 
be a very speedy operation, and hash maps provide this lookup in O(1) time. 
Also, our supplemental page table grows dynamically with every new page 
created to provide O(n) space complexity, where n is the number of pages 
being used by a process. 


		       PAGING TO AND FROM DISK
		       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.


in frame.c:
-----------

struct lock lock_frame;							/* a lock for synchronizing access to 
																			 the list of frames */
static struct list frame_list;			/* the list of all frames currently 
																			 in use */
struct list_elem *clock_hand;				/* the next frame to be considered for 
																			 eviction: the 'hand' of the clock 
																			 algorithm */

in swap.c:
----------

struct block *swap_device;					/* the starting disk block of the swap 
																			 partition */
static struct bitmap *swap_map;     /* a bitmap representing the 
																			 availability of the slots on disk */
struct lock lock_swap;							/* a global lock for synchronizing 
																			 access to the swap bitmap */

in pagesup.h:
-------------


/* contains the information for locating a page that lives in disk */
struct file_info
{
	struct file *file;
	off_t offset;
};

/* contains the information for locating a page that has been written to a 
swap slot */
struct swap_info
{
	size_t slot_index;
};

/* contains the information for locating a page that does not live in memory.
   such pages are either in a swap slot or in a file on disk */
union pagesup_info 
{
	struct file_info f;
	struct swap_info s;	
};

struct pagesup_entry 
{
	...

	union pagesup_info info;						/* information for retrieving a page
																 				 if it is not in memory */

	...

}


---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

We implement the clock algorithm to decide which page to evict. Frames are stored in a list of supplementary page table entries. We maintain a static list_elem pointer, called the clock hand. The clock hand steps down the list. When it gets to the end, it moves to the head of the list and starts again. At each element, the clock hand checks the page directory to see if this page has been accessed. If so, we clear the bit and continue. If not, we evict this frame. This algorithm is an approximation of Least Recently Used. 

Because the clock must first acquire the lock for a supplementary page table entry before checking if it can be evicted, pages which have been 'pinned' or are having their page table entries updated are not eligible for eviction, since their locks are already acquired by another process. 

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect that frame Q no longer has it?

We first call pagedir_clear_page to clear the page directory in hardware. This ensures that all future accesses to this page will page fault. We also remove the page supplementary table entry from the frame list, which means it is not in the frame table. Finally, we set the "location" field on the page supplement table entry struct to be either 'swap' or 'file' depending on where it was written to. The key is that its location is no longer set to be 'memory'.


>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

First we check to see if the stack address was legal - that is, we check that the address trying to be accessed is no more that 32 bytes below the current esp.

Assuming it is a legal access, we check to see if a stack extension is required. Each thread maintains a pointer to its current "stack base", which is a pointer the bottom of the memory that has been allocated for it. To check to see if we need an extension, we simply compare the faulting address to the current stack_base: if it is lower, we need to extend the stack. However, here we need another check to make sure that we are not extending beyond MIN_STACK_BASE, which represents the lowest possible address that the stack can be extended to. If we go beyond this address, we will exceed the allotted stack space.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

A thread must acquire the frame table lock before making any changes to the frame table. This means that the lock is acquired when a new frame is needed, and is held until a frame has been allocated or evicted. Furthermore, when checking a supplementary page table entry to see if it's frame can be evicted, one must hold the lock for that entry. 

To avoid deadlock, we maintain a hierarchy of lock acquisition. The frame lock must always be acquired before the locks for multiple page supplementary table entries are acquired. In this way we ensure that we don't have a circularity on lock acquisitions, which breaks the 4th necessary condition for deadlock.

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

While a frame is being evicted, the frame lock is being held by the process P. The first thing that process P will do is clear the page directory for that page. This ensures that  process Q will get a page fault if it tries to access that page. Upon getting a page fault, process Q will try to acquire the frame lock to load its faulted page back into memory. Here it will block until process P has completely finished the eviction process. Hence, Q cannot fault the page back in until P has taken it off the frame table and written it to disk (if necessary).

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

While process P was reading in a page from disk, it would be holding the frame table lock. No other process can begin the eviction process until it acquires the frame lock - hence, process Q must wait unti process P has successfully read in its page from disk before process Q can evict that page. The basic idea is that our system handles one page fault or eviction at a time. This ensures that we don't encounter race conditions between multiple evictions and page faults.

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

Kernel page faults are catastrophic and cause the kernel to crash
because the kernel attempts to acquire the IDE device lock that it already
holds. This is because a read or write system call invoked by a user 
process involves both an external file and a buffer location in user virtual
memory, so the kernel may page fault while trying to access the
user buffer after it has acquired the IDE lock, and therefore cannot
load the buffer memory page.

We use a pinning mechanism to avoid kernel page faults that might
occur during system calls. A page that is pinned is immediately
loaded into a physical memory frame and can NOT be evicted. This is
implemented through the use of locks on supplemental page table entries.

Prior to reading/writing the buffer from/to file, we verify that the
head and tail addresses of the buffer are valid user virtual addresses.
We then compute the addresses of all user pages (using the read/write size)
that the buffer spans and verify that they are installed in the 
supplemental page table. If any of these checks fail, we fail gracefully 
by terminating the user process, but the OS continues to run unaffected.

We then pin each buffer page individually before reading/writing its
data, and unpin it immediately after this operation is finished. We feel 
that page/frame pinning is a simple solution to this problem that does 
not incur significant overhead because only one page/frame may be pinned
at a given time for each given process.

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

Our design has several locks to prevent race conditions while still
allowing a high degree of parallelism.

Similar to the global filesystem lock that was implemented in project
2, we use a global lock on the frame list to ensure that there are
no race conditions when inspecting or modifying elements or the list
structure itself. We chose to use a global lock because the frame list 
itself is a global data structure that is shared among all active threads.

However, we use individual locks on the supplemental page table
entries for all processes. These locks must be acquired before inspecting
or modifying any entry fields.

Using multiple locks increases the likelihood of introducing
deadlock conditions. To prevent deadlock, we require that locks are acquired
in a specific order when multiple locks are needed for an operation.

The loading and eviction functions are the only tasks that need
to acquire multiple locks. For both of these routines, a process must first 
acquire the frame list lock before acquiring the supplemental page table
entry lock. During eviction of a frame, a process may modify the supplemental
page table entry owned by a different process, and it must acquire the
lock for that entry only after it has acquired the frame lock.

In all other cases, such as when a process needs to inspect or modify one
of its supplemental page table entries without modifying the frame list, the
owning process will block until that lock of that entry is released.


			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

-----------------------------
mmap.h
-----------------------------

typedef int mapid_t;						/* user identifier for memory mapped files
																   used as the hashed key in a mmap_table */
typedef struct hash mmap_table; /* type def for mmap_table hash table */

struct mmap_entry 
{
  mapid_t mid;						/* (hash key) mmap file identifier */
	void *upage;						/* first page in user memory */
	struct file *file;			/* handler of backing file */
	uint32_t file_len;			/* byte-size of file */
	struct hash_elem elem;	/* hash table element */
};

-----------------------------
process.c
-----------------------------

Each process/thread has its own mmap_table (hash table) of memory-mapped files.
The mmap_table is stored in the process_info struct:

struct process_info
{
	...
	mapid_t next_mid;     /* mapid_t counter localized to each process */
  mmap_table mmt;       /* hash table of memory mapped files */
	...
}

-----------------------------
pagesup.h
-----------------------------
enum page_type 					/* indicates the type of user memory page entry */
{
  ptype_stack,							/* stack page */
  ptype_segment,						/* writable segment page */
  ptype_segment_readonly,		/* read-only segment page */
  ptype_file								/* mem-mapped file page */
};

enum page_location			/* indicates the current location of a user page */
{
	ploc_none,				/* page data does not exist anywhere (new stack pages) */
	ploc_memory,			/* page data resides in a physical frame */
	ploc_file,				/* page data resides in an external file */
	ploc_swap					/* page data resides in a swap slot */
};

struct file_info			/* used to retrieve page data from file */
{
	struct file *file;	/* external file struct */
	off_t offset;				/* offset location within the file */
};

struct swap_info			/* used to retrieve page data from swap */
{
	size_t slot_index;	/* swap slot where the page data resides */
};

union pagesup_info		/* union for storing information about
											 external page data to be loaded in */
{										
	struct file_info f;		/* used to retrieve page data from file */
	struct swap_info s;		/* used to retrieve page data from swap */
};

struct pagesup_entry 			/* supplemental page table entry */
{
	void *upage; 						/* used to generate hash */
	void *kpage;						/* kernel page virtual address */
	int valid_bytes;				/* valid bytes on the give page */
	enum page_type ptype;		/* type of user page */
	enum page_location ploc;	/* current location of user page data */
	struct thread *owner;			/* pointer to owning thread, (used for eviction) */
	struct lock lock;					/* lock needed to modify struct fields */
	struct hash_elem pagesup_elem;	/* supplemental page table elem */
	struct list_elem frame_elem;    /* frame list elem */
	union pagesup_info info;	/* info for loading page data. the union is
															 cast as a file_info or swap_info depending
															 on the ptype
};

Each pagesup_entry contains a union pagesup_info, whose contents can either
be interpreted as a struct file_info or struct swap_info. For pages that are
installed for memory-mapped files, the contents of pagesup_info will always 
be accessed as a struct file_info.

We chose to use a UNION so that our supplemental page table entries could
be generalized to handle all types of loaded data (file, stack, segment), 
while still maintaining specificity of file locations versus swap slots 
when necessary.


---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

Our implementation differentiates between several types
of memory pages using an enum page_type indicator that is stored
in each of the supplemental page table entries. The page_type field 
is set by the OS during installation of a page and is inspected during
the loading and releasing of pages. These inspections are usually triggered
through page-faults, but occur when unmapping memory-mapped files as well.

When a file is mapped to memory by the user process using the 'mmap' system
call, we use the file-size to compute the number of necessary pages to install
in virtual memory for that file (after checking the validity of the user 
memory region). Then we install the appropriate number of pages to map the
file into the supplemental page table. Each of the installed page contains
a handle of the file struct containing the backing data, an offset indicating
where in the file the data for the page is located, and a number of valid_bytes
that the page contains. valid_bytes will be PGSIZE for all pages except for the
last, because the file may not contain an exact multiple of PGSIZE bytes.

Upon user-access of a mmapped page, the process of retrieving the underlying
data is nearly identical to that of code, data, or stack. After acquiring a
frame, the function vman_load_page_helper (in vman.c) detects the page has
ptype_file and issues a filesystem read to retreive the data.

If the OS is unable to acquire a frame during frame_alloc(), then eviction
will occur. If eviction occurs on a frame that corresponds to a memory-mapped
file's page, the eviction algorithm (frame_evict) will detect that the
page has ptype_file and will write the data back to the underlying file
(NOT swap) only if it is dirty. If the page is not dirty, there is no need to 
write out the data and the containing frame is released for use.

For writable segment pages (ptype_segment), eviction will write them to an
available swap slot, and for read-only segment pages (ptype_segment_readonly),
eviction will simply discard the contents since they can be fetched from
the executable again.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

The mmap system call retrieves file descriptor and the user virtual address
at which to start mapping the file, which must be page aligned. Given
the file descriptor, we retrieve the file length in bytes and compute the 
number of pages required to map the entire file. We iterate over all 
required user virtual addresses corresponding to the necessary pages
and verify that there does not already exist a mapping in the supplementary
page table (function vman_upages_unmapped). If a page mapping exists for any 
of the required pages, we know that the requested file mapping will overlap 
another segment and thus return an error (-1) to the user. If all of
the requested virtual pages are unmapped, we install the necessary virtual
pages into the supplemental page table.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.


All virtual pages, whether segment, stack, or mem-mapped files, are installed
into the supplemental page table using pagesup_entry structs and loaded lazily
as needed during page faults. While the semantics of segments and mmapped
files is similar, our implementation maintains unique interfaces to install 
segment and file mappings because it provides more readable code. For example,
emory-mapped files do not have regions of uninitialized data, and the
read/write permissions are determined when the file itself is opened, not
by the mapping process. However, segment pages must be explicitly installed
with this information when the executable header is interpreted. For 
specifics, see vman_map_file versus vman_map_segment.

We store two enum fields, ptype and ploc, in each entry to indicate how the 
OS should handle loads and evictions of each page/frame. The location field
ploc is primarily used for determining where writable segment data currently
resides, but all pages that have been loaded to physical frames have
their location set to ploc_memory to indicate that they are present.

The procedures for allocating/evicting frames and actually loading the page 
data is shared between all types of user pages. The eviction (frame_evict) and 
loading (vman_load_page) functions inspect the page type (ptype) field of
a given supplemental page table entry. For mem-mapped files, the loading
procedure will read the valid bytes to an active page, and the eviction
procedure will similarly write the valid bytes of a page back to the 
file if the page is dirty. Once a mem-mapped page is evicted, its location
ploc is set to ploc_file to indicate where it resides for later access.



			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

We felt that the implementation of memory-mapped files adds extra
work to this project without enriching the underlying OS system. It
could be omitted, 

Don't understand the significance of implementing memory mapped files.

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?